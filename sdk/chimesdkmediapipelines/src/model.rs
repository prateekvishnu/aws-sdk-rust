// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    BadRequest,
    #[allow(missing_docs)] // documentation missing in model
    Forbidden,
    #[allow(missing_docs)] // documentation missing in model
    NotFound,
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailure,
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailable,
    #[allow(missing_docs)] // documentation missing in model
    Throttling,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "BadRequest" => ErrorCode::BadRequest,
            "Forbidden" => ErrorCode::Forbidden,
            "NotFound" => ErrorCode::NotFound,
            "ResourceLimitExceeded" => ErrorCode::ResourceLimitExceeded,
            "ServiceFailure" => ErrorCode::ServiceFailure,
            "ServiceUnavailable" => ErrorCode::ServiceUnavailable,
            "Throttling" => ErrorCode::Throttling,
            other => ErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ErrorCode::from(s))
    }
}
impl ErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ErrorCode::BadRequest => "BadRequest",
            ErrorCode::Forbidden => "Forbidden",
            ErrorCode::NotFound => "NotFound",
            ErrorCode::ResourceLimitExceeded => "ResourceLimitExceeded",
            ErrorCode::ServiceFailure => "ServiceFailure",
            ErrorCode::ServiceUnavailable => "ServiceUnavailable",
            ErrorCode::Throttling => "Throttling",
            ErrorCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "BadRequest",
            "Forbidden",
            "NotFound",
            "ResourceLimitExceeded",
            "ServiceFailure",
            "ServiceUnavailable",
            "Throttling",
        ]
    }
}
impl AsRef<str> for ErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a tag applied to a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The key of the tag.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag.</p>
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The key of the tag.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the tag.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the tag.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>A summary of a media capture pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MediaCapturePipelineSummary {
    /// <p>The ID of a media capture pipeline.</p>
    pub media_pipeline_id: std::option::Option<std::string::String>,
    /// <p>The ARN of a media capture pipeline.</p>
    pub media_pipeline_arn: std::option::Option<std::string::String>,
}
impl MediaCapturePipelineSummary {
    /// <p>The ID of a media capture pipeline.</p>
    pub fn media_pipeline_id(&self) -> std::option::Option<&str> {
        self.media_pipeline_id.as_deref()
    }
    /// <p>The ARN of a media capture pipeline.</p>
    pub fn media_pipeline_arn(&self) -> std::option::Option<&str> {
        self.media_pipeline_arn.as_deref()
    }
}
impl std::fmt::Debug for MediaCapturePipelineSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MediaCapturePipelineSummary");
        formatter.field("media_pipeline_id", &self.media_pipeline_id);
        formatter.field("media_pipeline_arn", &self.media_pipeline_arn);
        formatter.finish()
    }
}
/// See [`MediaCapturePipelineSummary`](crate::model::MediaCapturePipelineSummary)
pub mod media_capture_pipeline_summary {
    /// A builder for [`MediaCapturePipelineSummary`](crate::model::MediaCapturePipelineSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) media_pipeline_id: std::option::Option<std::string::String>,
        pub(crate) media_pipeline_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a media capture pipeline.</p>
        pub fn media_pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_pipeline_id = Some(input.into());
            self
        }
        /// <p>The ID of a media capture pipeline.</p>
        pub fn set_media_pipeline_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.media_pipeline_id = input;
            self
        }
        /// <p>The ARN of a media capture pipeline.</p>
        pub fn media_pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_pipeline_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a media capture pipeline.</p>
        pub fn set_media_pipeline_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.media_pipeline_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`MediaCapturePipelineSummary`](crate::model::MediaCapturePipelineSummary)
        pub fn build(self) -> crate::model::MediaCapturePipelineSummary {
            crate::model::MediaCapturePipelineSummary {
                media_pipeline_id: self.media_pipeline_id,
                media_pipeline_arn: self.media_pipeline_arn,
            }
        }
    }
}
impl MediaCapturePipelineSummary {
    /// Creates a new builder-style object to manufacture [`MediaCapturePipelineSummary`](crate::model::MediaCapturePipelineSummary)
    pub fn builder() -> crate::model::media_capture_pipeline_summary::Builder {
        crate::model::media_capture_pipeline_summary::Builder::default()
    }
}

/// <p>A media capture pipeline object consisting of an ID, source type, source ARN, a sink type, a sink ARN, and a configuration object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MediaCapturePipeline {
    /// <p>The ID of a media capture pipeline.</p>
    pub media_pipeline_id: std::option::Option<std::string::String>,
    /// <p>The ARN of a media capture pipeline.</p>
    pub media_pipeline_arn: std::option::Option<std::string::String>,
    /// <p>Source type from which media artifacts are saved. You must use <code>ChimeMeeting</code>.</p>
    pub source_type: std::option::Option<crate::model::MediaPipelineSourceType>,
    /// <p>ARN of the source from which the media artifacts are saved.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The status of the media capture pipeline.</p>
    pub status: std::option::Option<crate::model::MediaPipelineStatus>,
    /// <p>Destination type to which the media artifacts are saved. You must use an S3 Bucket.</p>
    pub sink_type: std::option::Option<crate::model::MediaPipelineSinkType>,
    /// <p>ARN of the destination to which the media artifacts are saved.</p>
    pub sink_arn: std::option::Option<std::string::String>,
    /// <p>The time at which the capture pipeline was created, in ISO 8601 format.</p>
    pub created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the capture pipeline was updated, in ISO 8601 format.</p>
    pub updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The configuration for a specified media capture pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
    pub chime_sdk_meeting_configuration:
        std::option::Option<crate::model::ChimeSdkMeetingConfiguration>,
}
impl MediaCapturePipeline {
    /// <p>The ID of a media capture pipeline.</p>
    pub fn media_pipeline_id(&self) -> std::option::Option<&str> {
        self.media_pipeline_id.as_deref()
    }
    /// <p>The ARN of a media capture pipeline.</p>
    pub fn media_pipeline_arn(&self) -> std::option::Option<&str> {
        self.media_pipeline_arn.as_deref()
    }
    /// <p>Source type from which media artifacts are saved. You must use <code>ChimeMeeting</code>.</p>
    pub fn source_type(&self) -> std::option::Option<&crate::model::MediaPipelineSourceType> {
        self.source_type.as_ref()
    }
    /// <p>ARN of the source from which the media artifacts are saved.</p>
    pub fn source_arn(&self) -> std::option::Option<&str> {
        self.source_arn.as_deref()
    }
    /// <p>The status of the media capture pipeline.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::MediaPipelineStatus> {
        self.status.as_ref()
    }
    /// <p>Destination type to which the media artifacts are saved. You must use an S3 Bucket.</p>
    pub fn sink_type(&self) -> std::option::Option<&crate::model::MediaPipelineSinkType> {
        self.sink_type.as_ref()
    }
    /// <p>ARN of the destination to which the media artifacts are saved.</p>
    pub fn sink_arn(&self) -> std::option::Option<&str> {
        self.sink_arn.as_deref()
    }
    /// <p>The time at which the capture pipeline was created, in ISO 8601 format.</p>
    pub fn created_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    /// <p>The time at which the capture pipeline was updated, in ISO 8601 format.</p>
    pub fn updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_timestamp.as_ref()
    }
    /// <p>The configuration for a specified media capture pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
    pub fn chime_sdk_meeting_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ChimeSdkMeetingConfiguration> {
        self.chime_sdk_meeting_configuration.as_ref()
    }
}
impl std::fmt::Debug for MediaCapturePipeline {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MediaCapturePipeline");
        formatter.field("media_pipeline_id", &self.media_pipeline_id);
        formatter.field("media_pipeline_arn", &self.media_pipeline_arn);
        formatter.field("source_type", &self.source_type);
        formatter.field("source_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("status", &self.status);
        formatter.field("sink_type", &self.sink_type);
        formatter.field("sink_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("created_timestamp", &self.created_timestamp);
        formatter.field("updated_timestamp", &self.updated_timestamp);
        formatter.field(
            "chime_sdk_meeting_configuration",
            &self.chime_sdk_meeting_configuration,
        );
        formatter.finish()
    }
}
/// See [`MediaCapturePipeline`](crate::model::MediaCapturePipeline)
pub mod media_capture_pipeline {
    /// A builder for [`MediaCapturePipeline`](crate::model::MediaCapturePipeline)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) media_pipeline_id: std::option::Option<std::string::String>,
        pub(crate) media_pipeline_arn: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<crate::model::MediaPipelineSourceType>,
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::MediaPipelineStatus>,
        pub(crate) sink_type: std::option::Option<crate::model::MediaPipelineSinkType>,
        pub(crate) sink_arn: std::option::Option<std::string::String>,
        pub(crate) created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) chime_sdk_meeting_configuration:
            std::option::Option<crate::model::ChimeSdkMeetingConfiguration>,
    }
    impl Builder {
        /// <p>The ID of a media capture pipeline.</p>
        pub fn media_pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_pipeline_id = Some(input.into());
            self
        }
        /// <p>The ID of a media capture pipeline.</p>
        pub fn set_media_pipeline_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.media_pipeline_id = input;
            self
        }
        /// <p>The ARN of a media capture pipeline.</p>
        pub fn media_pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_pipeline_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a media capture pipeline.</p>
        pub fn set_media_pipeline_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.media_pipeline_arn = input;
            self
        }
        /// <p>Source type from which media artifacts are saved. You must use <code>ChimeMeeting</code>.</p>
        pub fn source_type(mut self, input: crate::model::MediaPipelineSourceType) -> Self {
            self.source_type = Some(input);
            self
        }
        /// <p>Source type from which media artifacts are saved. You must use <code>ChimeMeeting</code>.</p>
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::MediaPipelineSourceType>,
        ) -> Self {
            self.source_type = input;
            self
        }
        /// <p>ARN of the source from which the media artifacts are saved.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        /// <p>ARN of the source from which the media artifacts are saved.</p>
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>The status of the media capture pipeline.</p>
        pub fn status(mut self, input: crate::model::MediaPipelineStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the media capture pipeline.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::MediaPipelineStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Destination type to which the media artifacts are saved. You must use an S3 Bucket.</p>
        pub fn sink_type(mut self, input: crate::model::MediaPipelineSinkType) -> Self {
            self.sink_type = Some(input);
            self
        }
        /// <p>Destination type to which the media artifacts are saved. You must use an S3 Bucket.</p>
        pub fn set_sink_type(
            mut self,
            input: std::option::Option<crate::model::MediaPipelineSinkType>,
        ) -> Self {
            self.sink_type = input;
            self
        }
        /// <p>ARN of the destination to which the media artifacts are saved.</p>
        pub fn sink_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sink_arn = Some(input.into());
            self
        }
        /// <p>ARN of the destination to which the media artifacts are saved.</p>
        pub fn set_sink_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sink_arn = input;
            self
        }
        /// <p>The time at which the capture pipeline was created, in ISO 8601 format.</p>
        pub fn created_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_timestamp = Some(input);
            self
        }
        /// <p>The time at which the capture pipeline was created, in ISO 8601 format.</p>
        pub fn set_created_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_timestamp = input;
            self
        }
        /// <p>The time at which the capture pipeline was updated, in ISO 8601 format.</p>
        pub fn updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_timestamp = Some(input);
            self
        }
        /// <p>The time at which the capture pipeline was updated, in ISO 8601 format.</p>
        pub fn set_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_timestamp = input;
            self
        }
        /// <p>The configuration for a specified media capture pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
        pub fn chime_sdk_meeting_configuration(
            mut self,
            input: crate::model::ChimeSdkMeetingConfiguration,
        ) -> Self {
            self.chime_sdk_meeting_configuration = Some(input);
            self
        }
        /// <p>The configuration for a specified media capture pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
        pub fn set_chime_sdk_meeting_configuration(
            mut self,
            input: std::option::Option<crate::model::ChimeSdkMeetingConfiguration>,
        ) -> Self {
            self.chime_sdk_meeting_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`MediaCapturePipeline`](crate::model::MediaCapturePipeline)
        pub fn build(self) -> crate::model::MediaCapturePipeline {
            crate::model::MediaCapturePipeline {
                media_pipeline_id: self.media_pipeline_id,
                media_pipeline_arn: self.media_pipeline_arn,
                source_type: self.source_type,
                source_arn: self.source_arn,
                status: self.status,
                sink_type: self.sink_type,
                sink_arn: self.sink_arn,
                created_timestamp: self.created_timestamp,
                updated_timestamp: self.updated_timestamp,
                chime_sdk_meeting_configuration: self.chime_sdk_meeting_configuration,
            }
        }
    }
}
impl MediaCapturePipeline {
    /// Creates a new builder-style object to manufacture [`MediaCapturePipeline`](crate::model::MediaCapturePipeline)
    pub fn builder() -> crate::model::media_capture_pipeline::Builder {
        crate::model::media_capture_pipeline::Builder::default()
    }
}

/// <p>The configuration object of the Amazon Chime SDK meeting for a specified media capture pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChimeSdkMeetingConfiguration {
    /// <p>The source configuration for a specified media capture pipline.</p>
    pub source_configuration: std::option::Option<crate::model::SourceConfiguration>,
    /// <p>The configuration for the artifacts in an Amazon Chime SDK meeting.</p>
    pub artifacts_configuration: std::option::Option<crate::model::ArtifactsConfiguration>,
}
impl ChimeSdkMeetingConfiguration {
    /// <p>The source configuration for a specified media capture pipline.</p>
    pub fn source_configuration(&self) -> std::option::Option<&crate::model::SourceConfiguration> {
        self.source_configuration.as_ref()
    }
    /// <p>The configuration for the artifacts in an Amazon Chime SDK meeting.</p>
    pub fn artifacts_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ArtifactsConfiguration> {
        self.artifacts_configuration.as_ref()
    }
}
impl std::fmt::Debug for ChimeSdkMeetingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChimeSdkMeetingConfiguration");
        formatter.field("source_configuration", &self.source_configuration);
        formatter.field("artifacts_configuration", &self.artifacts_configuration);
        formatter.finish()
    }
}
/// See [`ChimeSdkMeetingConfiguration`](crate::model::ChimeSdkMeetingConfiguration)
pub mod chime_sdk_meeting_configuration {
    /// A builder for [`ChimeSdkMeetingConfiguration`](crate::model::ChimeSdkMeetingConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_configuration: std::option::Option<crate::model::SourceConfiguration>,
        pub(crate) artifacts_configuration:
            std::option::Option<crate::model::ArtifactsConfiguration>,
    }
    impl Builder {
        /// <p>The source configuration for a specified media capture pipline.</p>
        pub fn source_configuration(mut self, input: crate::model::SourceConfiguration) -> Self {
            self.source_configuration = Some(input);
            self
        }
        /// <p>The source configuration for a specified media capture pipline.</p>
        pub fn set_source_configuration(
            mut self,
            input: std::option::Option<crate::model::SourceConfiguration>,
        ) -> Self {
            self.source_configuration = input;
            self
        }
        /// <p>The configuration for the artifacts in an Amazon Chime SDK meeting.</p>
        pub fn artifacts_configuration(
            mut self,
            input: crate::model::ArtifactsConfiguration,
        ) -> Self {
            self.artifacts_configuration = Some(input);
            self
        }
        /// <p>The configuration for the artifacts in an Amazon Chime SDK meeting.</p>
        pub fn set_artifacts_configuration(
            mut self,
            input: std::option::Option<crate::model::ArtifactsConfiguration>,
        ) -> Self {
            self.artifacts_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ChimeSdkMeetingConfiguration`](crate::model::ChimeSdkMeetingConfiguration)
        pub fn build(self) -> crate::model::ChimeSdkMeetingConfiguration {
            crate::model::ChimeSdkMeetingConfiguration {
                source_configuration: self.source_configuration,
                artifacts_configuration: self.artifacts_configuration,
            }
        }
    }
}
impl ChimeSdkMeetingConfiguration {
    /// Creates a new builder-style object to manufacture [`ChimeSdkMeetingConfiguration`](crate::model::ChimeSdkMeetingConfiguration)
    pub fn builder() -> crate::model::chime_sdk_meeting_configuration::Builder {
        crate::model::chime_sdk_meeting_configuration::Builder::default()
    }
}

/// <p>The configuration for the artifacts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ArtifactsConfiguration {
    /// <p>The configuration for the audio artifacts.</p>
    pub audio: std::option::Option<crate::model::AudioArtifactsConfiguration>,
    /// <p>The configuration for the video artifacts.</p>
    pub video: std::option::Option<crate::model::VideoArtifactsConfiguration>,
    /// <p>The configuration for the content artifacts.</p>
    pub content: std::option::Option<crate::model::ContentArtifactsConfiguration>,
}
impl ArtifactsConfiguration {
    /// <p>The configuration for the audio artifacts.</p>
    pub fn audio(&self) -> std::option::Option<&crate::model::AudioArtifactsConfiguration> {
        self.audio.as_ref()
    }
    /// <p>The configuration for the video artifacts.</p>
    pub fn video(&self) -> std::option::Option<&crate::model::VideoArtifactsConfiguration> {
        self.video.as_ref()
    }
    /// <p>The configuration for the content artifacts.</p>
    pub fn content(&self) -> std::option::Option<&crate::model::ContentArtifactsConfiguration> {
        self.content.as_ref()
    }
}
impl std::fmt::Debug for ArtifactsConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArtifactsConfiguration");
        formatter.field("audio", &self.audio);
        formatter.field("video", &self.video);
        formatter.field("content", &self.content);
        formatter.finish()
    }
}
/// See [`ArtifactsConfiguration`](crate::model::ArtifactsConfiguration)
pub mod artifacts_configuration {
    /// A builder for [`ArtifactsConfiguration`](crate::model::ArtifactsConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) audio: std::option::Option<crate::model::AudioArtifactsConfiguration>,
        pub(crate) video: std::option::Option<crate::model::VideoArtifactsConfiguration>,
        pub(crate) content: std::option::Option<crate::model::ContentArtifactsConfiguration>,
    }
    impl Builder {
        /// <p>The configuration for the audio artifacts.</p>
        pub fn audio(mut self, input: crate::model::AudioArtifactsConfiguration) -> Self {
            self.audio = Some(input);
            self
        }
        /// <p>The configuration for the audio artifacts.</p>
        pub fn set_audio(
            mut self,
            input: std::option::Option<crate::model::AudioArtifactsConfiguration>,
        ) -> Self {
            self.audio = input;
            self
        }
        /// <p>The configuration for the video artifacts.</p>
        pub fn video(mut self, input: crate::model::VideoArtifactsConfiguration) -> Self {
            self.video = Some(input);
            self
        }
        /// <p>The configuration for the video artifacts.</p>
        pub fn set_video(
            mut self,
            input: std::option::Option<crate::model::VideoArtifactsConfiguration>,
        ) -> Self {
            self.video = input;
            self
        }
        /// <p>The configuration for the content artifacts.</p>
        pub fn content(mut self, input: crate::model::ContentArtifactsConfiguration) -> Self {
            self.content = Some(input);
            self
        }
        /// <p>The configuration for the content artifacts.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<crate::model::ContentArtifactsConfiguration>,
        ) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`ArtifactsConfiguration`](crate::model::ArtifactsConfiguration)
        pub fn build(self) -> crate::model::ArtifactsConfiguration {
            crate::model::ArtifactsConfiguration {
                audio: self.audio,
                video: self.video,
                content: self.content,
            }
        }
    }
}
impl ArtifactsConfiguration {
    /// Creates a new builder-style object to manufacture [`ArtifactsConfiguration`](crate::model::ArtifactsConfiguration)
    pub fn builder() -> crate::model::artifacts_configuration::Builder {
        crate::model::artifacts_configuration::Builder::default()
    }
}

/// <p>The content artifact object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContentArtifactsConfiguration {
    /// <p>Indicates whether the content artifact is enabled or disabled.</p>
    pub state: std::option::Option<crate::model::ArtifactsState>,
    /// <p>The MUX type of the artifact configuration.</p>
    pub mux_type: std::option::Option<crate::model::ContentMuxType>,
}
impl ContentArtifactsConfiguration {
    /// <p>Indicates whether the content artifact is enabled or disabled.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ArtifactsState> {
        self.state.as_ref()
    }
    /// <p>The MUX type of the artifact configuration.</p>
    pub fn mux_type(&self) -> std::option::Option<&crate::model::ContentMuxType> {
        self.mux_type.as_ref()
    }
}
impl std::fmt::Debug for ContentArtifactsConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContentArtifactsConfiguration");
        formatter.field("state", &self.state);
        formatter.field("mux_type", &self.mux_type);
        formatter.finish()
    }
}
/// See [`ContentArtifactsConfiguration`](crate::model::ContentArtifactsConfiguration)
pub mod content_artifacts_configuration {
    /// A builder for [`ContentArtifactsConfiguration`](crate::model::ContentArtifactsConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::ArtifactsState>,
        pub(crate) mux_type: std::option::Option<crate::model::ContentMuxType>,
    }
    impl Builder {
        /// <p>Indicates whether the content artifact is enabled or disabled.</p>
        pub fn state(mut self, input: crate::model::ArtifactsState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Indicates whether the content artifact is enabled or disabled.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ArtifactsState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The MUX type of the artifact configuration.</p>
        pub fn mux_type(mut self, input: crate::model::ContentMuxType) -> Self {
            self.mux_type = Some(input);
            self
        }
        /// <p>The MUX type of the artifact configuration.</p>
        pub fn set_mux_type(
            mut self,
            input: std::option::Option<crate::model::ContentMuxType>,
        ) -> Self {
            self.mux_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ContentArtifactsConfiguration`](crate::model::ContentArtifactsConfiguration)
        pub fn build(self) -> crate::model::ContentArtifactsConfiguration {
            crate::model::ContentArtifactsConfiguration {
                state: self.state,
                mux_type: self.mux_type,
            }
        }
    }
}
impl ContentArtifactsConfiguration {
    /// Creates a new builder-style object to manufacture [`ContentArtifactsConfiguration`](crate::model::ContentArtifactsConfiguration)
    pub fn builder() -> crate::model::content_artifacts_configuration::Builder {
        crate::model::content_artifacts_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContentMuxType {
    #[allow(missing_docs)] // documentation missing in model
    ContentOnly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContentMuxType {
    fn from(s: &str) -> Self {
        match s {
            "ContentOnly" => ContentMuxType::ContentOnly,
            other => ContentMuxType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContentMuxType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContentMuxType::from(s))
    }
}
impl ContentMuxType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContentMuxType::ContentOnly => "ContentOnly",
            ContentMuxType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ContentOnly"]
    }
}
impl AsRef<str> for ContentMuxType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ArtifactsState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ArtifactsState {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => ArtifactsState::Disabled,
            "Enabled" => ArtifactsState::Enabled,
            other => ArtifactsState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ArtifactsState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ArtifactsState::from(s))
    }
}
impl ArtifactsState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ArtifactsState::Disabled => "Disabled",
            ArtifactsState::Enabled => "Enabled",
            ArtifactsState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for ArtifactsState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The video artifact configuration object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VideoArtifactsConfiguration {
    /// <p>Indicates whether the video artifact is enabled or disabled.</p>
    pub state: std::option::Option<crate::model::ArtifactsState>,
    /// <p>The MUX type of the video artifact configuration object.</p>
    pub mux_type: std::option::Option<crate::model::VideoMuxType>,
}
impl VideoArtifactsConfiguration {
    /// <p>Indicates whether the video artifact is enabled or disabled.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ArtifactsState> {
        self.state.as_ref()
    }
    /// <p>The MUX type of the video artifact configuration object.</p>
    pub fn mux_type(&self) -> std::option::Option<&crate::model::VideoMuxType> {
        self.mux_type.as_ref()
    }
}
impl std::fmt::Debug for VideoArtifactsConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VideoArtifactsConfiguration");
        formatter.field("state", &self.state);
        formatter.field("mux_type", &self.mux_type);
        formatter.finish()
    }
}
/// See [`VideoArtifactsConfiguration`](crate::model::VideoArtifactsConfiguration)
pub mod video_artifacts_configuration {
    /// A builder for [`VideoArtifactsConfiguration`](crate::model::VideoArtifactsConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::ArtifactsState>,
        pub(crate) mux_type: std::option::Option<crate::model::VideoMuxType>,
    }
    impl Builder {
        /// <p>Indicates whether the video artifact is enabled or disabled.</p>
        pub fn state(mut self, input: crate::model::ArtifactsState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Indicates whether the video artifact is enabled or disabled.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ArtifactsState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The MUX type of the video artifact configuration object.</p>
        pub fn mux_type(mut self, input: crate::model::VideoMuxType) -> Self {
            self.mux_type = Some(input);
            self
        }
        /// <p>The MUX type of the video artifact configuration object.</p>
        pub fn set_mux_type(
            mut self,
            input: std::option::Option<crate::model::VideoMuxType>,
        ) -> Self {
            self.mux_type = input;
            self
        }
        /// Consumes the builder and constructs a [`VideoArtifactsConfiguration`](crate::model::VideoArtifactsConfiguration)
        pub fn build(self) -> crate::model::VideoArtifactsConfiguration {
            crate::model::VideoArtifactsConfiguration {
                state: self.state,
                mux_type: self.mux_type,
            }
        }
    }
}
impl VideoArtifactsConfiguration {
    /// Creates a new builder-style object to manufacture [`VideoArtifactsConfiguration`](crate::model::VideoArtifactsConfiguration)
    pub fn builder() -> crate::model::video_artifacts_configuration::Builder {
        crate::model::video_artifacts_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VideoMuxType {
    #[allow(missing_docs)] // documentation missing in model
    VideoOnly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VideoMuxType {
    fn from(s: &str) -> Self {
        match s {
            "VideoOnly" => VideoMuxType::VideoOnly,
            other => VideoMuxType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VideoMuxType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VideoMuxType::from(s))
    }
}
impl VideoMuxType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VideoMuxType::VideoOnly => "VideoOnly",
            VideoMuxType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["VideoOnly"]
    }
}
impl AsRef<str> for VideoMuxType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The audio artifact configuration object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AudioArtifactsConfiguration {
    /// <p>The MUX type of the audio artifact configuration object.</p>
    pub mux_type: std::option::Option<crate::model::AudioMuxType>,
}
impl AudioArtifactsConfiguration {
    /// <p>The MUX type of the audio artifact configuration object.</p>
    pub fn mux_type(&self) -> std::option::Option<&crate::model::AudioMuxType> {
        self.mux_type.as_ref()
    }
}
impl std::fmt::Debug for AudioArtifactsConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AudioArtifactsConfiguration");
        formatter.field("mux_type", &self.mux_type);
        formatter.finish()
    }
}
/// See [`AudioArtifactsConfiguration`](crate::model::AudioArtifactsConfiguration)
pub mod audio_artifacts_configuration {
    /// A builder for [`AudioArtifactsConfiguration`](crate::model::AudioArtifactsConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mux_type: std::option::Option<crate::model::AudioMuxType>,
    }
    impl Builder {
        /// <p>The MUX type of the audio artifact configuration object.</p>
        pub fn mux_type(mut self, input: crate::model::AudioMuxType) -> Self {
            self.mux_type = Some(input);
            self
        }
        /// <p>The MUX type of the audio artifact configuration object.</p>
        pub fn set_mux_type(
            mut self,
            input: std::option::Option<crate::model::AudioMuxType>,
        ) -> Self {
            self.mux_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AudioArtifactsConfiguration`](crate::model::AudioArtifactsConfiguration)
        pub fn build(self) -> crate::model::AudioArtifactsConfiguration {
            crate::model::AudioArtifactsConfiguration {
                mux_type: self.mux_type,
            }
        }
    }
}
impl AudioArtifactsConfiguration {
    /// Creates a new builder-style object to manufacture [`AudioArtifactsConfiguration`](crate::model::AudioArtifactsConfiguration)
    pub fn builder() -> crate::model::audio_artifacts_configuration::Builder {
        crate::model::audio_artifacts_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AudioMuxType {
    #[allow(missing_docs)] // documentation missing in model
    AudioOnly,
    #[allow(missing_docs)] // documentation missing in model
    AudioWithActiveSpeakerVideo,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AudioMuxType {
    fn from(s: &str) -> Self {
        match s {
            "AudioOnly" => AudioMuxType::AudioOnly,
            "AudioWithActiveSpeakerVideo" => AudioMuxType::AudioWithActiveSpeakerVideo,
            other => AudioMuxType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AudioMuxType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AudioMuxType::from(s))
    }
}
impl AudioMuxType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AudioMuxType::AudioOnly => "AudioOnly",
            AudioMuxType::AudioWithActiveSpeakerVideo => "AudioWithActiveSpeakerVideo",
            AudioMuxType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AudioOnly", "AudioWithActiveSpeakerVideo"]
    }
}
impl AsRef<str> for AudioMuxType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Source configuration for a specified media capture pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceConfiguration {
    /// <p>The selected video streams to capture for a specified media capture pipeline. The number of video streams can't exceed 25.</p>
    pub selected_video_streams: std::option::Option<crate::model::SelectedVideoStreams>,
}
impl SourceConfiguration {
    /// <p>The selected video streams to capture for a specified media capture pipeline. The number of video streams can't exceed 25.</p>
    pub fn selected_video_streams(
        &self,
    ) -> std::option::Option<&crate::model::SelectedVideoStreams> {
        self.selected_video_streams.as_ref()
    }
}
impl std::fmt::Debug for SourceConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceConfiguration");
        formatter.field("selected_video_streams", &self.selected_video_streams);
        formatter.finish()
    }
}
/// See [`SourceConfiguration`](crate::model::SourceConfiguration)
pub mod source_configuration {
    /// A builder for [`SourceConfiguration`](crate::model::SourceConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) selected_video_streams: std::option::Option<crate::model::SelectedVideoStreams>,
    }
    impl Builder {
        /// <p>The selected video streams to capture for a specified media capture pipeline. The number of video streams can't exceed 25.</p>
        pub fn selected_video_streams(mut self, input: crate::model::SelectedVideoStreams) -> Self {
            self.selected_video_streams = Some(input);
            self
        }
        /// <p>The selected video streams to capture for a specified media capture pipeline. The number of video streams can't exceed 25.</p>
        pub fn set_selected_video_streams(
            mut self,
            input: std::option::Option<crate::model::SelectedVideoStreams>,
        ) -> Self {
            self.selected_video_streams = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceConfiguration`](crate::model::SourceConfiguration)
        pub fn build(self) -> crate::model::SourceConfiguration {
            crate::model::SourceConfiguration {
                selected_video_streams: self.selected_video_streams,
            }
        }
    }
}
impl SourceConfiguration {
    /// Creates a new builder-style object to manufacture [`SourceConfiguration`](crate::model::SourceConfiguration)
    pub fn builder() -> crate::model::source_configuration::Builder {
        crate::model::source_configuration::Builder::default()
    }
}

/// <p>The video streams to capture for a specified media capture pipeline. The total number of video streams can't exceed 25.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SelectedVideoStreams {
    /// <p>The attendee IDs of the streams selected for a media capture pipeline. </p>
    pub attendee_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The external user IDs of the streams selected for a media capture pipeline.</p>
    pub external_user_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl SelectedVideoStreams {
    /// <p>The attendee IDs of the streams selected for a media capture pipeline. </p>
    pub fn attendee_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.attendee_ids.as_deref()
    }
    /// <p>The external user IDs of the streams selected for a media capture pipeline.</p>
    pub fn external_user_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.external_user_ids.as_deref()
    }
}
impl std::fmt::Debug for SelectedVideoStreams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SelectedVideoStreams");
        formatter.field("attendee_ids", &self.attendee_ids);
        formatter.field("external_user_ids", &self.external_user_ids);
        formatter.finish()
    }
}
/// See [`SelectedVideoStreams`](crate::model::SelectedVideoStreams)
pub mod selected_video_streams {
    /// A builder for [`SelectedVideoStreams`](crate::model::SelectedVideoStreams)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attendee_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) external_user_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `attendee_ids`.
        ///
        /// To override the contents of this collection use [`set_attendee_ids`](Self::set_attendee_ids).
        ///
        /// <p>The attendee IDs of the streams selected for a media capture pipeline. </p>
        pub fn attendee_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.attendee_ids.unwrap_or_default();
            v.push(input.into());
            self.attendee_ids = Some(v);
            self
        }
        /// <p>The attendee IDs of the streams selected for a media capture pipeline. </p>
        pub fn set_attendee_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.attendee_ids = input;
            self
        }
        /// Appends an item to `external_user_ids`.
        ///
        /// To override the contents of this collection use [`set_external_user_ids`](Self::set_external_user_ids).
        ///
        /// <p>The external user IDs of the streams selected for a media capture pipeline.</p>
        pub fn external_user_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.external_user_ids.unwrap_or_default();
            v.push(input.into());
            self.external_user_ids = Some(v);
            self
        }
        /// <p>The external user IDs of the streams selected for a media capture pipeline.</p>
        pub fn set_external_user_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.external_user_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`SelectedVideoStreams`](crate::model::SelectedVideoStreams)
        pub fn build(self) -> crate::model::SelectedVideoStreams {
            crate::model::SelectedVideoStreams {
                attendee_ids: self.attendee_ids,
                external_user_ids: self.external_user_ids,
            }
        }
    }
}
impl SelectedVideoStreams {
    /// Creates a new builder-style object to manufacture [`SelectedVideoStreams`](crate::model::SelectedVideoStreams)
    pub fn builder() -> crate::model::selected_video_streams::Builder {
        crate::model::selected_video_streams::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MediaPipelineSinkType {
    #[allow(missing_docs)] // documentation missing in model
    S3Bucket,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MediaPipelineSinkType {
    fn from(s: &str) -> Self {
        match s {
            "S3Bucket" => MediaPipelineSinkType::S3Bucket,
            other => MediaPipelineSinkType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MediaPipelineSinkType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MediaPipelineSinkType::from(s))
    }
}
impl MediaPipelineSinkType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MediaPipelineSinkType::S3Bucket => "S3Bucket",
            MediaPipelineSinkType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["S3Bucket"]
    }
}
impl AsRef<str> for MediaPipelineSinkType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MediaPipelineStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Initializing,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MediaPipelineStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => MediaPipelineStatus::Failed,
            "InProgress" => MediaPipelineStatus::InProgress,
            "Initializing" => MediaPipelineStatus::Initializing,
            "Stopped" => MediaPipelineStatus::Stopped,
            "Stopping" => MediaPipelineStatus::Stopping,
            other => MediaPipelineStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MediaPipelineStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MediaPipelineStatus::from(s))
    }
}
impl MediaPipelineStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MediaPipelineStatus::Failed => "Failed",
            MediaPipelineStatus::InProgress => "InProgress",
            MediaPipelineStatus::Initializing => "Initializing",
            MediaPipelineStatus::Stopped => "Stopped",
            MediaPipelineStatus::Stopping => "Stopping",
            MediaPipelineStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Failed",
            "InProgress",
            "Initializing",
            "Stopped",
            "Stopping",
        ]
    }
}
impl AsRef<str> for MediaPipelineStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MediaPipelineSourceType {
    #[allow(missing_docs)] // documentation missing in model
    ChimeSdkMeeting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MediaPipelineSourceType {
    fn from(s: &str) -> Self {
        match s {
            "ChimeSdkMeeting" => MediaPipelineSourceType::ChimeSdkMeeting,
            other => MediaPipelineSourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MediaPipelineSourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MediaPipelineSourceType::from(s))
    }
}
impl MediaPipelineSourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MediaPipelineSourceType::ChimeSdkMeeting => "ChimeSdkMeeting",
            MediaPipelineSourceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ChimeSdkMeeting"]
    }
}
impl AsRef<str> for MediaPipelineSourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
